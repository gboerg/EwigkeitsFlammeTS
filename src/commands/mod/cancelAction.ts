import { AutocompleteInteraction, ChannelType, ChatInputCommandInteraction, CommandInteraction, InteractionContextType, MessageFlags, PermissionFlagsBits, SlashCommandBuilder, type GuildTextBasedChannel } from "discord.js";
import type { Command } from "../../types/command.ts";
import p from "../../database/database.ts";
import { DateTime } from "luxon";

export default {
    data: new SlashCommandBuilder()
    .setName("cancel")
    .setDescription("cancel any stacked action before this command")
    .setDefaultMemberPermissions(PermissionFlagsBits.BanMembers)
    .setContexts(InteractionContextType.Guild)
    .addStringOption(option => option
        .setName("action")
        .setDescription("select reoccuring action that need to be canceld")
        .setRequired(true)
        .setAutocomplete(true)
    ).addStringOption(option => option
        .setName("additional_params")
        .setDescription("just in case any addiotional params are required")
        .setRequired(false)
        // .setAutocomplete(true)
    ),
    execute: async (interaction: ChatInputCommandInteraction) => {
        await interaction.deferReply({flags: MessageFlags.Ephemeral})
        const guild = interaction.guild
        const command = interaction.options.getString("action")
        const user = interaction.user
        const time = DateTime.now().toUnixInteger()
        const channel = interaction.channel


        await p.actions.upsert({
            where: {
                // This is the unique identifier for the record we're looking for
                guild_id_command: { // This composite key name is generated by Prisma for @@unique fields
                    guild_id: guild.id,
                    command: command,
                },
            },
            create: {
                // Data to create if the record does NOT exist
                guild_id: guild.id,
                command: command,
                active: true,
                user_id: "none",
                timestamp: time, // Store as Unix timestamp (integer)
                channel_id: channel.id,
                executor: user.id,
                channel_name: channel.name
            },
            update: {
                // Data to update if the record DOES exist
                active: true,
                executor: user.id, // You might want to update user_id or keep the original
                timestamp: time, // Update timestamp on every actio

            },
        });
        await interaction.editReply(`${command} will be canceld`)
        await new Promise(resolve => setTimeout(resolve, 4000));
        await interaction.deleteReply()
    },
    autocomplete: async(interaction: AutocompleteInteraction) => {
        const focusedValue = interaction.options.getFocused();
        const guild = interaction.guild
        const dbEntry = await p.actions.findMany({
            select: {
                command: true,
                channel_id: true,
                user_id: true,
                active: true
            }, where: {
                guild_id: guild.id
            }
        })
        const choices = dbEntry.map(entry => ({ name: `Command: ${entry.command} | Im Channel: ${entry.channel_id}, `, value: entry.command}));

        const filtered = choices.filter(choice => choice.value.startsWith(focusedValue));
        await interaction.respond(filtered);
    }
}                